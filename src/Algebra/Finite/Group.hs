{-# LANGUAGE RankNTypes #-}
{-# LANGUAGE FunctionalDependencies #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE InstanceSigs #-}
{-# LANGUAGE ConstraintKinds #-}
{-# LANGUAGE TypeFamilies #-}

-- | The algebra of finite groups.
module Algebra.Finite.Group
  ( Group(..)
  , GroupElem
  , GroupLaw(..)
  , canonical
  , groupMulTable
  , groupInvTable
  -- * Subgroups
  , generated
  -- * Homomorphisms
  , GroupHomomorphism(..)
  , GroupHomomorphismLaw(..)
  ) where

import Algebra.Finite.Class ( Algebra(..), Morphism(..) )
import Algebra.Finite.Property ( Property(Property) )

import Data.Set (Set)
import qualified Data.Set as Set
import Data.Maybe (fromJust)
import Data.Tuple (swap)

-- | A finite group has a set of elements, a multiplication operation, an
-- inverse operation, and an identity element. Laws are closure for the three
-- operations, associativity of multiplication, left\/right inverses, and
-- left\/right identity.
data Group a = Group
  { gSet :: Set a       -- ^ Underlying set
  , gMul :: a -> a -> a -- ^ Group multiplication
  , gInv :: a -> a      -- ^ Multiplicative inverse
  , gId  :: a           -- ^ Multiplicative identity
  }

-- | Construct the multiplication table from a group.
groupMulTable :: Group a -> [(a, a, a)]
groupMulTable g = [ (a, b, gMul g a b) | a <- d, b <- d ]
  where d = Set.toList (gSet g)

-- | Construct the inversion table from a group.
groupInvTable :: Group a -> [(a, a)]
groupInvTable g = [ (a, gInv g a) | a <- Set.toList (gSet g) ]

-- | Given a group over any type, get an isomorphic group that uses 'Integer's
-- as elements.
canonical :: forall a . Ord a => Group a -> GroupHomomorphism a Integer
canonical g = GroupHomomorphism { ghDomain = g
                                , ghCodomain = canonicalGroup
                                , ghMap = aToInt
                                }
  where aIntTable :: [(a, Integer)]
        aIntTable = (gId g, 0) : zip (Set.toList (Set.delete (gId g) (gSet g))) [1..]

        aToInt :: a -> Integer
        aToInt a = fromJust (lookup a aIntTable)

        intToA :: Integer -> a
        intToA a = fromJust (lookup a (swap <$> aIntTable))

        canonicalGroup = Group
          { gSet = Set.fromList (snd <$> aIntTable)
          , gMul = \i j -> aToInt (gMul g (intToA i) (intToA j))
          , gInv = aToInt . gInv g . intToA
          , gId = 0
          }

instance Show (Group a) where
  show _ = "<group>"

-- | The laws that every valid group must satisfy.
data GroupLaw = IdClosed        -- ^ @e in g@.
              | InvClosed       -- ^ @forall a in g . inv a in g@.
              | MulClosed       -- ^ @forall a b in g . a * b in g@.
              | IdLeftIdentity  -- ^ @forall a in g . e * a = a@.
              | IdRightIdentity -- ^ @forall a in g . a * e = a@.
              | InvLeftInverse  -- ^ @forall a in g . inv a * a = e@.
              | InvRightInverse -- ^ @forall a in g . a * inv a = e@.
              | MulAssoc        -- ^ @forall a b c in g . (a * b) * c = a * (b * c)@.
  deriving Show

-- | The only requirement for the elements of a group is that we can insert them
-- into a set container.
class Ord a => GroupElem a

instance Algebra Group where
  type AlgebraLaw Group = GroupLaw
  type AlgebraElem Group = GroupElem

  algebraSet g = gSet g

  algebraLaws = [ (IdClosed       , \g -> Property $ gId g `elem` algebraSet g)
                , (InvClosed      , \g -> Property $ \a -> gInv g a `elem` algebraSet g)
                , (MulClosed      , \g -> Property $ \a b -> gMul g a b `elem` algebraSet g)
                , (IdLeftIdentity , \g -> Property $ \a -> gMul g (gId g) a == a)
                , (IdRightIdentity, \g -> Property $ \a -> gMul g a (gId g) == a)
                , (InvLeftInverse , \g -> Property $ \a -> gMul g (gInv g a) a == gId g)
                , (InvRightInverse, \g -> Property $ \a -> gMul g a (gInv g a) == gId g)
                , (MulAssoc       , \g -> Property $ \a b c -> gMul g (gMul g a b) c == gMul g a (gMul g b c))
                ]

-- | Get the cyclic subgroup generated by a single element of a group.
generated :: Ord a => Group a -> a -> Group a
generated g a = g
  { gSet = Set.fromList (gId g : takeWhile (/= gId g) (iterate (gMul g a) a)) }

-- | A group homomorphism is just a map on the underlying sets that respects
-- multiplication.
data GroupHomomorphism a b = GroupHomomorphism
  { ghDomain :: Group a
  , ghCodomain :: Group b
  , ghMap :: a -> b
  }

-- | The laws that every group homomorphism must satisfy.
data GroupHomomorphismLaw = GHRespectsMultiplication
                          | GHClosed
  deriving Show

instance Morphism GroupHomomorphism Group where
  type MorphismLaw GroupHomomorphism = GroupHomomorphismLaw

  morphismDomain = ghDomain
  morphismCodomain = ghCodomain
  morphism = ghMap
  morphismLaws = [ ( GHClosed
                   , \h -> Property $ \a -> ghMap h a `elem` gSet (ghCodomain h)
                   )
                 , ( GHRespectsMultiplication
                   , \h -> Property $ \a b -> ghMap h (gMul (ghDomain h) a b) == gMul (ghCodomain h) (ghMap h a) (ghMap h b)
                   )
                 ]
