module Algebra.Finite.Semigroup where

import Algebra.Finite.Class
import Algebra.Finite.Property


import Data.Set (Set)
import qualified Data.Set as Set
import Data.Maybe (fromJust)
import Data.Tuple (swap)
import qualified Text.PrettyPrint.Boxes as B

import Prelude hiding (Semigroup(..))

-- | A finite semigroup has a set of elements and a multiplication operation.
data Semigroup a = Semigroup
  { set :: Set a       -- ^ Underlying set
  , mul :: a -> a -> a -- ^ Semigroup multiplication
  }

-- -- | Construct the multiplication table from a group.
-- semigroupMulTable :: Group a -> [(a, [(a, a)])]
-- semigroupMulTable g = [ (a, [ (b, mul g a b) | b <- d ]) | a <- d ]
--   where d = Set.toList (set g)

-- -- | Construct the inversion table from a group.
-- semigroupInvTable :: Group a -> [(a, a)]
-- semigroupInvTable g = [ (a, gInv g a) | a <- Set.toList (set g) ]

-- -- | Given a group over any type, get an isomorphic group that uses 'Integer's
-- -- as elements.
-- canonical :: forall a . Ord a => Group a -> GroupHomomorphism a Integer
-- canonical g = GroupHomomorphism { ghDomain = g
--                                 , ghCodomain = canonicalGroup
--                                 , ghMap = aToInt
--                                 }
--   where aIntTable :: [(a, Integer)]
--         aIntTable = (e g, 0) : zip (Set.toList (Set.delete (e g) (set g))) [1..]

--         aToInt :: a -> Integer
--         aToInt a = fromJust (lookup a aIntTable)

--         intToA :: Integer -> a
--         intToA a = fromJust (lookup a (swap <$> aIntTable))

--         canonicalGroup = Group
--           { set = Set.fromList (snd <$> aIntTable)
--           , mul = \i j -> aToInt (mul g (intToA i) (intToA j))
--           , inv = aToInt . gInv g . intToA
--           , e = 0
--           }

-- instance Show (Group a) where
--   show _ = "<group>"

-- -- | The laws that every valid group must satisfy.
-- data GroupLaw = IdClosed        -- ^ @e in g@.
--               | InvClosed       -- ^ @forall a in g . inv a in g@.
--               | MulClosed       -- ^ @forall a b in g . a * b in g@.
--               | IdLeftIdentity  -- ^ @forall a in g . e * a = a@.
--               | IdRightIdentity -- ^ @forall a in g . a * e = a@.
--               | InvLeftInverse  -- ^ @forall a in g . inv a * a = e@.
--               | InvRightInverse -- ^ @forall a in g . a * inv a = e@.
--               | MulAssoc        -- ^ @forall a b c in g . (a * b) * c = a * (b * c)@.
--   deriving Show

-- -- | The only requirement for the elements of a group is that we can insert them
-- -- into a set container.
-- class Ord a => GroupElem a

-- instance Ord a => GroupElem a

-- instance Algebra Group where
--   type AlgebraLaw Group = GroupLaw
--   type AlgebraElem Group = GroupElem

--   algebraSet g = set g

--   algebraLaws = groupLaws

-- instance SemigroupLike Group where
--   sgMul = mul
--   sgMulAssoc _ = MulAssoc
--   sgMulClosed _ = MulClosed

-- instance MonoidLike Group where
--   mId = e
--   mIdClosed _ = IdClosed
--   mLeftIdentity _ = IdLeftIdentity
--   mRightIdentity _ = IdRightIdentity

-- instance GroupLike Group where
--   gInv = inv
--   gInvClosed _ = InvClosed
--   gInvLeftInverse _ = InvLeftInverse
--   gInvRightInverse _ = InvRightInverse

-- -- | Get the subgroup generated by some subset of a group.
-- generated :: Ord a => Group a -> Set a -> Group a
-- generated g aSet = g { set = gen (Set.insert (e g) aSet) }
--   where gen s | s' == s = s
--               | otherwise = gen s'
--           where s' = multiplySets g s s

-- -- | A group homomorphism is just a map on the underlying sets that respects
-- -- multiplication.
-- data GroupHomomorphism a b = GroupHomomorphism
--   { ghDomain :: Group a
--   , ghCodomain :: Group b
--   , ghMap :: a -> b
--   }

-- -- | The laws that every group homomorphism must satisfy.
-- data GroupHomomorphismLaw = GHRespectsMultiplication
--                           | GHClosed
--   deriving Show

-- instance Morphism GroupHomomorphism Group where
--   type MorphismLaw GroupHomomorphism = GroupHomomorphismLaw

--   morphismDomain = ghDomain
--   morphismCodomain = ghCodomain
--   morphism = ghMap
--   morphismLaws = [ ( GHClosed
--                    , \h -> Property $ \a -> ghMap h a `elem` set (ghCodomain h)
--                    )
--                  , ( GHRespectsMultiplication
--                    , \h -> Property $ \a b -> ghMap h (mul (ghDomain h) a b) == mul (ghCodomain h) (ghMap h a) (ghMap h b)
--                    )
--                  ]

-- -- | Get the kernel of a group homomorphism.
-- kernel :: (GroupElem a, GroupElem b) => GroupHomomorphism a b -> Group a
-- kernel phi = (ghDomain phi) { set = g' }
--   where g' =  Set.fromList [ a | a <- Set.toList (set (ghDomain phi))
--                                , morphism phi a == e (ghCodomain phi)
--                                ]

-- -- | Get the image of a group homomorphism.
-- image :: (GroupElem a, GroupElem b) => GroupHomomorphism a b -> Group b
-- image phi = (ghCodomain phi) { set = g' }
--   where g' = Set.fromList [ morphism phi a | a <- Set.toList (set (ghDomain phi)) ]

-- -- | Get a left coset of a subgroup.
-- leftCoset :: Ord a
--           => a
--           -> Group a
--           -- ^ subgroup
--           -> Set a
-- leftCoset a g = Set.fromList [ mul g a b | b <- Set.toList (set g) ]

-- -- | Get a right coset of a subgroup.
-- rightCoset :: Ord a
--            => Group a
--            -- ^ subgroup
--            -> a
--            -> Set a
-- rightCoset g a = Set.fromList [ mul g b a | b <- Set.toList (set g) ]

-- -- | Multiply two sets together to get another set. This is always a
-- -- well-defined operation on sets, but only gives rise to a quotient group if
-- -- the sets involved are cosets of a
-- multiplySets :: Ord a
--              => Group a
--                 -- ^ Group containing the sets
--              -> Set a
--              -- ^ set 1
--              -> Set a
--              -- ^ set 2
--              -> Set a
-- multiplySets g aSet bSet = Set.fromList [ mul g a b | a <- as, b <- bs ]
--   where as = Set.toList aSet
--         bs = Set.toList bSet

-- -- | Take the group inverse of every element in a set, forming a new set. When
-- -- the input set is a coset of a normal subgroup, this acts as an inverse
-- -- operation for the quotient group.
-- inverseSet :: Ord a
--            => Group a
--            -> Set a
--            -> Set a
-- inverseSet g s = Set.fromList [ inv g a | a <- Set.toList s ]

-- -- | Given a parent group @g@ and a normal subgroup @h@, form the quotient group
-- -- @g/h@ of left cosets of @h@.
-- leftQuotientGroup :: Ord a
--                   => Group a
--                   -- ^ Parent group
--                   -> Group a
--                   -- ^ Subgroup (must be normal, or the cosets do not form a group)
--                   -> Group (Set a)
-- leftQuotientGroup g h = Group
--   { set = Set.fromList [ leftCoset a h | a <- Set.toList (set g) ]
--   , mul = multiplySets g
--   , inv = inverseSet g
--   , e = set h
--   }

-- -- | Given a parent group @g@ and a normal subgroup @h@, form the quotient group
-- -- @g/h@ of left cosets of @h@. Note that this should be the same as
-- -- 'leftQuotientGroup' when @h@ is normal, but if @h@ is not normal, the
-- -- quotient group isn't actually a group, and the cosets will differe in general
-- -- depending on whether we are taking left or right cosets.
-- rightQuotientGroup :: Ord a
--                    => Group a
--                    -- ^ Parent group
--                    -> Group a
--                    -- ^ Subgroup (must be normal, or the cosets do not form a group)
--                    -> Group (Set a)
-- rightQuotientGroup g h = Group
--   { set = Set.fromList [ rightCoset h a | a <- Set.toList (set g) ]
--   , mul = multiplySets g
--   , inv = inverseSet g
--   , e = set h
--   }

-- -- | Alias for 'leftQuotientGroup'.
-- quotientGroup :: Ord a => Group a -> Group a -> Group (Set a)
-- quotientGroup = leftQuotientGroup


-- ppMulTable' :: Show a => Group a -> B.Box
-- ppMulTable' g = B.punctuateH B.center1 vbar $ allCols
--   where as = Set.toList (set g)

--         leftmostCol = B.punctuateV B.center1 hbar $
--                       B.char '*' : [ B.text (show a) | a <- as ]

--         mkCol b = B.punctuateV B.center1 hbar $
--                   B.text (show b) : [ B.text (show (mul g a b)) | a <- as ]

--         allCols = leftmostCol : [ mkCol b | b <- as ]

--         vbar = B.text "|"
--         -- hbar = B.text (replicate (maximum (length . B.render <$> allRows)) '-')
--         hbar = B.text "-"

-- -- | Pretty-print a group's multiplication table.
-- ppMulTable :: Show a => Group a -> String
-- ppMulTable g = B.render (ppMulTable' g)

