{-# LANGUAGE RankNTypes #-}
{-# LANGUAGE FunctionalDependencies #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE InstanceSigs #-}
{-# LANGUAGE ConstraintKinds #-}
{-# LANGUAGE TypeFamilies #-}
{-# LANGUAGE UndecidableInstances #-}

-- | The algebra of finite groups.
module Algebra.Finite.Group
  ( -- * Groups
    Group(..)
  , muls
  , GroupElem
  , GroupLaw(..)
  , integerRenaming
  , groupMulTable
  , groupInvTable
  -- * Subgroups
  , generated
  -- * Cosets and quotient groups
  , leftCoset
  , rightCoset
  , multiplySets
  , inverseSet
  , leftQuotientGroup
  , rightQuotientGroup
  , quotientGroup
  -- * Homomorphisms
  , GroupHomomorphism(..)
  , GroupHomomorphismLaw(..)
  , kernel
  , image
  -- * Centralizers and normalizers
  , centralizer
  ) where

import Algebra.Finite.Class
import Algebra.Finite.Property ( Property(Property) )
import Algebra.Finite.Set

import Data.Maybe (fromJust)
import Data.Tuple (swap)

-- | A finite group has a set of elements, a multiplication operation, an
-- inverse operation, and an identity element. Laws are closure for the three
-- operations, associativity of multiplication, left\/right inverses, and
-- left\/right identity.
data Group a = Group
  { set :: Set a       -- ^ Underlying set
  , mul :: a -> a -> a -- ^ Group multiplication
  , inv :: a -> a      -- ^ Multiplicative inverse
  , e   :: a           -- ^ Multiplicative identity
  }

muls :: Group a -> [a] -> a
muls g as = foldr (mul g) (e g) as

-- | Construct the multiplication table from a group.
groupMulTable :: Group a -> [(a, [(a, a)])]
groupMulTable g = [ (a, [ (b, mul g a b) | b <- d ]) | a <- d ]
  where d = toList (set g)

-- | Construct the inversion table from a group.
groupInvTable :: Group a -> [(a, a)]
groupInvTable g = [ (a, gInv g a) | a <- toList (set g) ]

-- | Given a group over any type, get an isomorphic group that uses 'Integer's
-- as elements.
integerRenaming :: forall a . Ord a => Group a -> GroupHomomorphism a Integer
integerRenaming g = GroupHomomorphism { ghDomain = g
                                      , ghCodomain = canonicalGroup
                                      , ghMap = aToInt
                                      }
  where aIntTable :: [(a, Integer)]
        aIntTable = (e g, 0) : zip (toList (delete (e g) (set g))) [1..]

        aToInt :: a -> Integer
        aToInt a = fromJust (lookup a aIntTable)

        intToA :: Integer -> a
        intToA a = fromJust (lookup a (swap <$> aIntTable))

        canonicalGroup = Group
          { set = fromList (snd <$> aIntTable)
          , mul = \i j -> aToInt (mul g (intToA i) (intToA j))
          , inv = aToInt . gInv g . intToA
          , e = 0
          }

instance Show (Group a) where
  show _ = "<group>"

-- | The laws that every valid group must satisfy.
data GroupLaw = IdClosed        -- ^ @e in g@.
              | InvClosed       -- ^ @forall a in g . inv a in g@.
              | MulClosed       -- ^ @forall a b in g . a * b in g@.
              | IdLeftIdentity  -- ^ @forall a in g . e * a = a@.
              | IdRightIdentity -- ^ @forall a in g . a * e = a@.
              | InvLeftInverse  -- ^ @forall a in g . inv a * a = e@.
              | InvRightInverse -- ^ @forall a in g . a * inv a = e@.
              | MulAssoc        -- ^ @forall a b c in g . (a * b) * c = a * (b * c)@.
  deriving Show

-- | The only requirement for the elements of a group is that we can insert them
-- into a set container.
class Ord a => GroupElem a

instance Ord a => GroupElem a

instance Algebra Group where
  type AlgebraLaw Group = GroupLaw
  type AlgebraElem Group = GroupElem

  algebraSet g = let Set s = set g in s

  algebraLaws = groupLaws

instance SemigroupLike Group where
  sgMul = mul
  sgMulAssoc _ = MulAssoc
  sgMulClosed _ = MulClosed

instance MonoidLike Group where
  mId = e
  mIdClosed _ = IdClosed
  mLeftIdentity _ = IdLeftIdentity
  mRightIdentity _ = IdRightIdentity

instance GroupLike Group where
  gInv = inv
  gInvClosed _ = InvClosed
  gInvLeftInverse _ = InvLeftInverse
  gInvRightInverse _ = InvRightInverse

-- | Get the subgroup generated by some subset of a group.
generated :: Ord a => Group a -> Set a -> Group a
generated g aSet = g { set = gen (insert (e g) aSet) }
  where gen s | s' == s = s
              | otherwise = gen s'
          where s' = multiplySets g s s

-- | A group homomorphism is just a map on the underlying sets that respects
-- multiplication.
data GroupHomomorphism a b = GroupHomomorphism
  { ghDomain :: Group a
  , ghCodomain :: Group b
  , ghMap :: a -> b
  }

-- | The laws that every group homomorphism must satisfy.
data GroupHomomorphismLaw = GHRespectsMultiplication
                          | GHClosed
  deriving Show

instance Morphism GroupHomomorphism Group where
  type MorphismLaw GroupHomomorphism = GroupHomomorphismLaw

  morphismDomain = ghDomain
  morphismCodomain = ghCodomain
  morphism = ghMap
  morphismLaws = [ ( GHClosed
                   , \h -> Property $ \a -> ghMap h a `elem` set (ghCodomain h)
                   )
                 , ( GHRespectsMultiplication
                   , \h -> Property $ \a b -> ghMap h (mul (ghDomain h) a b) == mul (ghCodomain h) (ghMap h a) (ghMap h b)
                   )
                 ]

-- | Get the kernel of a group homomorphism.
kernel :: (GroupElem a, GroupElem b) => GroupHomomorphism a b -> Group a
kernel phi = (ghDomain phi) { set = g' }
  where g' =  fromList [ a | a <- toList (set (ghDomain phi))
                           , morphism phi a == e (ghCodomain phi)
                           ]

-- | Get the image of a group homomorphism.
image :: (GroupElem a, GroupElem b) => GroupHomomorphism a b -> Group b
image phi = (ghCodomain phi) { set = g' }
  where g' = fromList [ morphism phi a | a <- toList (set (ghDomain phi)) ]

-- | Get a left coset of a subgroup.
leftCoset :: Ord a
          => a
          -> Group a
          -- ^ subgroup
          -> Set a
leftCoset a g = fromList [ mul g a b | b <- toList (set g) ]

-- | Get a right coset of a subgroup.
rightCoset :: Ord a
           => Group a
           -- ^ subgroup
           -> a
           -> Set a
rightCoset g a = fromList [ mul g b a | b <- toList (set g) ]

-- | Multiply two sets together to get another set. This is always a
-- well-defined operation on sets, but only gives rise to a quotient group if
-- the sets involved are cosets of a
multiplySets :: Ord a
             => Group a
                -- ^ Group containing the sets
             -> Set a
             -- ^ set 1
             -> Set a
             -- ^ set 2
             -> Set a
multiplySets g aSet bSet = fromList [ mul g a b | a <- as, b <- bs ]
  where as = toList aSet
        bs = toList bSet

-- | Take the group inverse of every element in a set, forming a new set. When
-- the input set is a coset of a normal subgroup, this acts as an inverse
-- operation for the quotient group.
inverseSet :: Ord a
           => Group a
           -> Set a
           -> Set a
inverseSet g s = fromList [ inv g a | a <- toList s ]

-- | Given a parent group @g@ and a normal subgroup @h@, form the quotient group
-- @g/h@ of left cosets of @h@.
leftQuotientGroup :: Ord a
                  => Group a
                  -- ^ Parent group
                  -> Group a
                  -- ^ Subgroup (must be normal, or the cosets do not form a group)
                  -> Group (Set a)
leftQuotientGroup g h = Group
  { set = fromList [ leftCoset a h | a <- toList (set g) ]
  , mul = multiplySets g
  , inv = inverseSet g
  , e = set h
  }

-- | Given a parent group @g@ and a normal subgroup @h@, form the quotient group
-- @g/h@ of left cosets of @h@. Note that this should be the same as
-- 'leftQuotientGroup' when @h@ is normal, but if @h@ is not normal, the
-- quotient group isn't actually a group, and the cosets will differe in general
-- depending on whether we are taking left or right cosets.
rightQuotientGroup :: Ord a
                   => Group a
                   -- ^ Parent group
                   -> Group a
                   -- ^ Subgroup (must be normal, or the cosets do not form a group)
                   -> Group (Set a)
rightQuotientGroup g h = Group
  { set = fromList [ rightCoset h a | a <- toList (set g) ]
  , mul = multiplySets g
  , inv = inverseSet g
  , e = set h
  }

-- | Alias for 'leftQuotientGroup'.
quotientGroup :: Ord a => Group a -> Group a -> Group (Set a)
quotientGroup = leftQuotientGroup

centralizer :: Ord a => Group a -> Set a -> Group a
centralizer g a = g { set = c }
  where c = fromList [ x | x <- toList (set g)
                         , all (\y -> muls g [x,y,inv g x] == y) (toList a)
                         ]
