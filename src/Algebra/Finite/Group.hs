{-# LANGUAGE RankNTypes #-}
{-# LANGUAGE FunctionalDependencies #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE InstanceSigs #-}
module Algebra.Finite.Group
  ( Group(..)
  , GroupLaw(..)
  , GroupHomomorphism(..)
  , canonical
  , groupMulTable
  , groupInvTable
  -- * Subgroups
  , generated
  -- * Homomorphisms
  ) where

import Algebra.Finite.Class ( Algebra(..), Morphism(..) )
import Algebra.Finite.Property ( Property(Property) )

import Data.Set (Set)
import qualified Data.Set as Set
import Data.Maybe (fromJust)
import Data.Tuple (swap)

-- | A finite group has a set of elements, a multiplication operation, an
-- inverse operation, and an identity element. Laws are closure for the three
-- operations, associativity of multiplication, left\/right inverses, and
-- left\/right identity.
data Group a = Group
  { gSet :: Set a
  , gMul :: a -> a -> a
  , gInv :: a -> a
  , gId  :: a
  }

-- | Construct the multiplication table from a group.
groupMulTable :: Group a -> [(a, a, a)]
groupMulTable g = [ (a, b, gMul g a b) | a <- d, b <- d ]
  where d = Set.toList (gSet g)

-- | Construct the inversion table from a group.
groupInvTable :: Group a -> [(a, a)]
groupInvTable g = [ (a, gInv g a) | a <- Set.toList (gSet g) ]

-- | Given a group over any type, get an isomorphic group that uses 'Integer's
-- as elements.
canonical :: forall a . Ord a => Group a -> GroupHomomorphism a Integer
canonical g = GroupHomomorphism { ghDomain = g
                                , ghCodomain = canonicalGroup
                                , ghMap = aToInt
                                }
  where aIntTable :: [(a, Integer)]
        aIntTable = (gId g, 0) : zip (Set.toList (Set.delete (gId g) (gSet g))) [1..]

        aToInt :: a -> Integer
        aToInt a = fromJust (lookup a aIntTable)

        intToA :: Integer -> a
        intToA a = fromJust (lookup a (swap <$> aIntTable))

        canonicalGroup = Group
          { gSet = Set.fromList (snd <$> aIntTable)
          , gMul = \i j -> aToInt (gMul g (intToA i) (intToA j))
          , gInv = aToInt . gInv g . intToA
          , gId = 0
          }

instance Show (Group a) where
  show _ = "<group>"

data GroupLaw = IdClosed
              | InvClosed
              | MulClosed
              | IdLeftIdentity
              | IdRightIdentity
              | InvLeftInverse
              | InvRightInverse
              | MulAssoc
  deriving Show

instance Eq a => Algebra (Group a) a GroupLaw where
  algebraSet g = gSet g

  algebraLaws = [ (IdClosed       , \g -> Property $ gId g `elem` algebraSet g)
                , (InvClosed      , \g -> Property $ \a -> gInv g a `elem` algebraSet g)
                , (MulClosed      , \g -> Property $ \a b -> gMul g a b `elem` algebraSet g)
                , (IdLeftIdentity , \g -> Property $ \a -> gMul g (gId g) a == a)
                , (IdRightIdentity, \g -> Property $ \a -> gMul g a (gId g) == a)
                , (InvLeftInverse , \g -> Property $ \a -> gMul g (gInv g a) a == gId g)
                , (InvRightInverse, \g -> Property $ \a -> gMul g a (gInv g a) == gId g)
                , (MulAssoc       , \g -> Property $ \a b c -> gMul g (gMul g a b) c == gMul g a (gMul g b c))
                ]

-- | Get the cyclic subgroup generated by a single element of a group.
generated :: Ord a => Group a -> a -> Group a
generated g a = g
  { gSet = Set.fromList (gId g : takeWhile (/= gId g) (iterate (gMul g a) a)) }

-- | A group homomorphism is just a map on the underlying sets that respects
-- multiplication.
data GroupHomomorphism a b = GroupHomomorphism
  { ghDomain :: Group a
  , ghCodomain :: Group b
  , ghMap :: a -> b
  }

data GroupHomomorphismLaw = GHRespectsMultiplication
                          | GHClosed
  deriving Show

instance (Eq a, Eq b) => Morphism (GroupHomomorphism a b) GroupHomomorphismLaw (Group a) (Group b) a b GroupLaw where
  morphismDomain = ghDomain
  morphismCodomain = ghCodomain
  morphism = ghMap
  morphismLaws = [ (GHClosed
                   , \h -> Property $ \a -> ghMap h a `elem` gSet (ghCodomain h)
                   )
                 , ( GHRespectsMultiplication
                   , \h -> Property $ \a b -> ghMap h (gMul (ghDomain h) a b) == gMul (ghCodomain h) (ghMap h a) (ghMap h b)
                   )
                 ]
