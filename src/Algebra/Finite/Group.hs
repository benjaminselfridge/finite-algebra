{-# LANGUAGE RankNTypes #-}
{-# LANGUAGE FunctionalDependencies #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE InstanceSigs #-}
{-# LANGUAGE ConstraintKinds #-}
{-# LANGUAGE TypeFamilies #-}
{-# LANGUAGE UndecidableInstances #-}

-- | The algebra of finite groups.
module Algebra.Finite.Group
  ( Group(..)
  , GroupElem
  , GroupLaw(..)
  , canonical
  , groupMulTable
  , groupInvTable
  -- * Subgroups
  , generated
  -- * Cosets and quotient groups
  , leftCoset
  , rightCoset
  , multiplySets
  , inverseSet
  , leftQuotientGroup
  , rightQuotientGroup
  , quotientGroup
  -- * Homomorphisms
  , GroupHomomorphism(..)
  , GroupHomomorphismLaw(..)
  , kernel
  , image
  ) where

import Algebra.Finite.Class ( Algebra(..), Morphism(..) )
import Algebra.Finite.Property ( Property(Property) )

import Data.Set (Set)
import qualified Data.Set as Set
import Data.Maybe (fromJust)
import Data.Tuple (swap)

-- | A finite group has a set of elements, a multiplication operation, an
-- inverse operation, and an identity element. Laws are closure for the three
-- operations, associativity of multiplication, left\/right inverses, and
-- left\/right identity.
data Group a = Group
  { gSet :: Set a       -- ^ Underlying set
  , gMul :: a -> a -> a -- ^ Group multiplication
  , gInv :: a -> a      -- ^ Multiplicative inverse
  , gId  :: a           -- ^ Multiplicative identity
  }

-- | Construct the multiplication table from a group.
groupMulTable :: Group a -> [(a, [(a, a)])]
groupMulTable g = [ (a, [ (b, gMul g a b) | b <- d ]) | a <- d ]
  where d = Set.toList (gSet g)

-- | Construct the inversion table from a group.
groupInvTable :: Group a -> [(a, a)]
groupInvTable g = [ (a, gInv g a) | a <- Set.toList (gSet g) ]

-- | Given a group over any type, get an isomorphic group that uses 'Integer's
-- as elements.
canonical :: forall a . Ord a => Group a -> GroupHomomorphism a Integer
canonical g = GroupHomomorphism { ghDomain = g
                                , ghCodomain = canonicalGroup
                                , ghMap = aToInt
                                }
  where aIntTable :: [(a, Integer)]
        aIntTable = (gId g, 0) : zip (Set.toList (Set.delete (gId g) (gSet g))) [1..]

        aToInt :: a -> Integer
        aToInt a = fromJust (lookup a aIntTable)

        intToA :: Integer -> a
        intToA a = fromJust (lookup a (swap <$> aIntTable))

        canonicalGroup = Group
          { gSet = Set.fromList (snd <$> aIntTable)
          , gMul = \i j -> aToInt (gMul g (intToA i) (intToA j))
          , gInv = aToInt . gInv g . intToA
          , gId = 0
          }

instance Show (Group a) where
  show _ = "<group>"

-- | The laws that every valid group must satisfy.
data GroupLaw = IdClosed        -- ^ @e in g@.
              | InvClosed       -- ^ @forall a in g . inv a in g@.
              | MulClosed       -- ^ @forall a b in g . a * b in g@.
              | IdLeftIdentity  -- ^ @forall a in g . e * a = a@.
              | IdRightIdentity -- ^ @forall a in g . a * e = a@.
              | InvLeftInverse  -- ^ @forall a in g . inv a * a = e@.
              | InvRightInverse -- ^ @forall a in g . a * inv a = e@.
              | MulAssoc        -- ^ @forall a b c in g . (a * b) * c = a * (b * c)@.
  deriving Show

-- | The only requirement for the elements of a group is that we can insert them
-- into a set container.
class Ord a => GroupElem a

instance Ord a => GroupElem a

instance Algebra Group where
  type AlgebraLaw Group = GroupLaw
  type AlgebraElem Group = GroupElem

  algebraSet g = gSet g

  algebraLaws =
    [ (IdClosed       , \g -> Property $ gId g `elem` algebraSet g)
    , (InvClosed      , \g -> Property $ \a -> gInv g a `elem` algebraSet g)
    , (MulClosed      , \g -> Property $ \a b -> gMul g a b `elem` algebraSet g)
    , (IdLeftIdentity , \g -> Property $ \a -> gMul g (gId g) a == a)
    , (IdRightIdentity, \g -> Property $ \a -> gMul g a (gId g) == a)
    , (InvLeftInverse , \g -> Property $ \a -> gMul g (gInv g a) a == gId g)
    , (InvRightInverse, \g -> Property $ \a -> gMul g a (gInv g a) == gId g)
    , (MulAssoc       , \g -> Property $ \a b c -> gMul g (gMul g a b) c == gMul g a (gMul g b c))
    ]

-- | Get the cyclic subgroup generated by a single element of a group.
generated :: Ord a => Group a -> a -> Group a
generated g a = g
  { gSet = Set.fromList (gId g : takeWhile (/= gId g) (iterate (gMul g a) a)) }

-- | A group homomorphism is just a map on the underlying sets that respects
-- multiplication.
data GroupHomomorphism a b = GroupHomomorphism
  { ghDomain :: Group a
  , ghCodomain :: Group b
  , ghMap :: a -> b
  }

-- | The laws that every group homomorphism must satisfy.
data GroupHomomorphismLaw = GHRespectsMultiplication
                          | GHClosed
  deriving Show

instance Morphism GroupHomomorphism Group where
  type MorphismLaw GroupHomomorphism = GroupHomomorphismLaw

  morphismDomain = ghDomain
  morphismCodomain = ghCodomain
  morphism = ghMap
  morphismLaws = [ ( GHClosed
                   , \h -> Property $ \a -> ghMap h a `elem` gSet (ghCodomain h)
                   )
                 , ( GHRespectsMultiplication
                   , \h -> Property $ \a b -> ghMap h (gMul (ghDomain h) a b) == gMul (ghCodomain h) (ghMap h a) (ghMap h b)
                   )
                 ]

-- | Get the kernel of a group homomorphism.
kernel :: (GroupElem a, GroupElem b) => GroupHomomorphism a b -> Group a
kernel phi = (ghDomain phi) { gSet = g' }
  where g' =  Set.fromList [ a | a <- Set.toList (gSet (ghDomain phi))
                               , morphism phi a == gId (ghCodomain phi)
                               ]

-- | Get the image of a group homomorphism.
image :: (GroupElem a, GroupElem b) => GroupHomomorphism a b -> Group b
image phi = (ghCodomain phi) { gSet = g' }
  where g' = Set.fromList [ morphism phi a | a <- Set.toList (gSet (ghDomain phi)) ]

-- | Get a left coset of a subgroup.
leftCoset :: Ord a
          => a
          -> Group a
          -- ^ subgroup
          -> Set a
leftCoset a g = Set.fromList [ gMul g a b | b <- Set.toList (gSet g) ]

-- | Get a right coset of a subgroup.
rightCoset :: Ord a
           => Group a
           -- ^ subgroup
           -> a
           -> Set a
rightCoset g a = Set.fromList [ gMul g b a | b <- Set.toList (gSet g) ]

-- | Multiply two sets together to get another set. This is always a
-- well-defined operation on sets, but only gives rise to a quotient group if
-- the sets involved are cosets of a
multiplySets :: Ord a
             => Group a
                -- ^ Group containing the sets
             -> Set a
             -- ^ set 1
             -> Set a
             -- ^ set 2
             -> Set a
multiplySets g aSet bSet = Set.fromList [ gMul g a b | a <- as, b <- bs ]
  where as = Set.toList aSet
        bs = Set.toList bSet

-- | Take the group inverse of every element in a set, forming a new set. When
-- the input set is a coset of a normal subgroup, this acts as an inverse
-- operation for the quotient group.
inverseSet :: Ord a
           => Group a
           -> Set a
           -> Set a
inverseSet g set = Set.fromList [ gInv g a | a <- Set.toList set ]

-- | Given a parent group @g@ and a normal subgroup @h@, form the quotient group
-- @g/h@ of left cosets of @h@.
leftQuotientGroup :: Ord a
                  => Group a
                  -- ^ Parent group
                  -> Group a
                  -- ^ Subgroup (must be normal, or the cosets do not form a group)
                  -> Group (Set a)
leftQuotientGroup g h = Group
  { gSet = Set.fromList [ leftCoset a h | a <- Set.toList (gSet g) ]
  , gMul = multiplySets g
  , gInv = inverseSet g
  , gId = gSet h
  }

-- | Given a parent group @g@ and a normal subgroup @h@, form the quotient group
-- @g/h@ of left cosets of @h@. Note that this should be the same as
-- 'leftQuotientGroup' when @h@ is normal, but if @h@ is not normal, the
-- quotient group isn't actually a group, and the cosets will differe in general
-- depending on whether we are taking left or right cosets.
rightQuotientGroup :: Ord a
                   => Group a
                   -- ^ Parent group
                   -> Group a
                   -- ^ Subgroup (must be normal, or the cosets do not form a group)
                   -> Group (Set a)
rightQuotientGroup g h = Group
  { gSet = Set.fromList [ rightCoset h a | a <- Set.toList (gSet g) ]
  , gMul = multiplySets g
  , gInv = inverseSet g
  , gId = gSet h
  }

-- | Alias for 'leftQuotientGroup'.
quotientGroup :: Ord a => Group a -> Group a -> Group (Set a)
quotientGroup = leftQuotientGroup
